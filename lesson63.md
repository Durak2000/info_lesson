### параграф 63
### вопросы

1. Почему при поиске индекса максимального элемента необязательно хранить само значение максимального элемента?  

При поиске индекса максимального элемента достаточно хранить только индекс, потому что его можно использовать для доступа к элементу в массиве. Если мы уже знаем индекс, то можем сразу обратиться к массиву и получить значение элемента. Это экономит память и упрощает исходный алгоритм.

2. Что такое реверс массива? 

Реверс массива – это операция, при которой порядок элементов массива меняется на обратный. То есть первый элемент становится последним, второй — предпоследним и так далее.

3. Как вы думаете, какую ошибку чаще всего делают начинающие программисты, программируя реверс массива?  

Начинающие программисты могут забывать о необходимости завершить процесс до достижения середины массива или неправильно рассчитывать индексы, что может привести к перезаписи элементов или выходу за границы массива.

4. Как вы думаете, какие проблемы (и ошибки) могут возникнуть при циклическом сдвиге массива вправо?  

При циклическом сдвиге вправо возможны следующие проблемы:
- Перезапись исходных данных, так как сдвигаемые элементы могут затереть значения, которые еще не были сдвинуты.
- Ошибка при работе с границами массива, например, если не учтены индексы, что может привести к выходу за границы.

5. Что произойдёт с массивом при выполнении следующего фрагмента программы?  

Фрагмент программы имеет неопределённое поведение, поскольку при каждом запуске выполняется присваивание A1+1 = A1, и это будет бесконечный цикл, если только не добавлен выход из него. В конечном итоге, если этот фрагмент выполняется в контексте программы без предусловий, массив останется неизменным или закончится выполнением с ошибкой.

6. Как при использовании приведённого алгоритма поиска определить, что элемент не найден?  

Чтобы определить, что элемент не найден, нужно после завершения поиска проверить, было ли сделано успешное сравнение или изменение индекса. Если индекс не изменился или остался равным первоначальному значению, элемент считается не найденным.

7. Что такое выход за границы массива? Почему он может быть опасен?  

Выход за границы массива происходит, когда происходит попытка доступа к элементу по индексу, который либо меньше 0, либо больше (или равен) размеру массива. Это может быть опасно, потому что может привести к повреждению данных, некорректным результатам или аварийному завершению программы.

8. Опишите «очевидный» алгоритм отбора части элементов одного массива в другой массив. Почему его не используют?  

«Очевидный» алгоритм может выглядеть следующим образом:

1. Создать новый массив с нужным размером.
2. Итерировать по элементам первого массива.
3. Копировать элементы в новый массив на основе заданного условия.

Код на Python:
original_array = [1, 2, 3, 4, 5, 6, 7, 8, 9]
selected_elements = []
for i in range(len(original_array)):
    if original_array[i] % 2 == 0:  # выбираем только четные элементы
        selected_elements.append(original_array[i])


### задачи 

```
1. Напишите программу, которая находит максимальный и минимальный из элементов массива с чётными положительными значениями. Если в массиве нет элементов с чётными положительными значениями, нужно вывести сообщение об этом.

def find_min_max_even_positive(arr):
    even_positive_numbers = [num for num in arr if num > 0 and num % 2 == 0]
    
    if not even_positive_numbers:
        return "Нет элементов с чётными положительными значениями"
    
    return min(even_positive_numbers), max(even_positive_numbers)

array = [1, -2, 3, 4, 5, 6, -10, 2]
result = find_min_max_even_positive(array)
print(result)


2. Введите массив с клавиатуры и найдите (за один проход) количество элементов, имеющих максимальное значение.

array = list(map(int, input("Введите элементы массива через пробел: ").split()))
max_value = max(array)
count_max = sum(1 for x in array if x == max_value)
print("Количество элементов с максимальным значением:", count_max)


3. Найдите за один проход по массиву три его различных элемента, которые меньше всех остальных («три минимума»).

def find_three_minima(arr):
    unique_arr = list(set(arr))
    unique_arr.sort()
    
    return unique_arr[:3] if len(unique_arr) >= 3 else unique_arr

array = [8, 3, 1, 6, 2, 4, 1, 7]
result = find_three_minima(array)
print("Три минимума:", result)


4. Заполните массив случайными числами в диапазоне 10..12 и найдите длину самой длинной последовательности стоящих рядом элементов с одинаковыми значениями.

import random

array = [random.randint(10, 12) for _ in range(20)]
max_length = current_length = 1

for i in range(1, len(array)):
    if array[i] == array[i - 1]:
        current_length += 1
        max_length = max(max_length, current_length)
    else:
        current_length = 1

print("Массив:", array)
print("Длина самой длинной последовательности:", max_length)


5. Заполните массив случайными числами в диапазоне 0..4 и выведите на экран номера всех элементов, значение которых равно х (Х вводится с клавиатуры).

x = int(input("Введите число x (от 0 до 4): "))
array = [random.randint(0, 4) for _ in range(20)]
indexes = [i for i, value in enumerate(array) if value == x]

print("Массив:", array)
print("Индексы элементов, равных x:", indexes)


6. Заполните массив случайными числами и переставьте соседние элементы, поменяв 1-й элемент со 2-м, 3-й с 4-м и т. д.

array = [random.randint(0, 100) for _ in range(10)]
for i in range(0, len(array) - 1, 2):
    array[i], array[i + 1] = array[i + 1], array[i]

print("Перемешанный массив:", array)


7. Заполните массив с чётным количеством элементов случайными числами и выполните реверс отдельно для первой и второй половин массива.

array = [random.randint(1, 100) for _ in range(10)]
mid = len(array) // 2

array[:mid] = reversed(array[:mid])
array[mid:] = reversed(array[mid:])

print("Реверсированный массив:", array)


8. Заполните массив случайными числами и выполните реверс для части массива между элементами с индексами к и м (включая эти элементы).

k = int(input("Введите индекс k: "))
m = int(input("Введите индекс m: "))
array = [random.randint(1, 100) for _ in range(10)]

array[k:m+1] = reversed(array[k:m+1])
print("Массив после реверса:", array)


9. Напишите программу для выполнения циклического сдвига массива вправо на 4 элемента.

array = [random.randint(1, 100) for _ in range(10)]
n = len(array)
shift = 4

shifted_array = array[-shift:] + array[:-shift]
print("Массив после циклического сдвига вправо:", shifted_array)


10. Найдите в массиве все простые числа и скопируйте их в новый массив.

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

array = [random.randint(1, 100) for _ in range(20)]
primes = [num for num in array if is_prime(num)]

print("Массив:", array)
print("Простые числа:", primes)


11. Найдите в массиве все числа Фибоначчи и скопируйте их в новый массив.

def fibonacci_numbers(n):
    fibs = [0, 1]
    while fibs[-1] < n:
        fibs.append(fibs[-1] + fibs[-2])
    return set(fibs)

array = [random.randint(0, 100) for _ in range(20)]
fib_set = fibonacci_numbers(100)
fibonacci_in_array = [num for num in array if num in fib_set]

print("Массив:", array)
print("Числа Фибоначчи:", fibonacci_in_array)
