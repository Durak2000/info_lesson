## Ответы на вопросы

1. Что такое сортировка?
   Сортировка — это процесс упорядочивания элементов в массиве или списке по заданному критерию, например, по возрастанию или убыванию.

2. На какой идее основан метод пузырька? Метод выбора?
   - Метод пузырька основан на последовательном сравнении соседних элементов и их перестановке, если они находятся в неправильном порядке. Этот процесс повторяется, пока весь массив не будет отсортирован.
   - Метод выбора основывается на нахождении минимального (или максимального) элемента из неотсортированной части массива и его перемещении в отсортированную часть.

3. Объясните, зачем нужен вложенный цикл в описанных методах сортировки.
   Вложенный цикл нужен для того, чтобы пройтись по всем элементам массива. В методе пузырька внешний цикл отвечает за проход по массиву, а вложенный цикл сравнивает и переставляет элементы. В методе выбора внешний цикл выбирает элемент для сортировки, а внутренний ищет минимальный/максимальный элемент.

4. Сравните на примере метод пузырька и метод выбора. Какой из них требует меньше перестановок?
   В методе пузырька происходит много перестановок, особенно при сортировке неотсортированного массива. Метод выбора выполняет меньшее количество перестановок, так как каждый раз он перемещает только один элемент в отсортированную часть.

5. Расскажите про основные идеи метода «быстрой сортировки».
   Быстрая сортировка основана на принципе «разделяй и властвуй». Идея заключается в выборе опорного элемента, разделении массива на две части (меньшие и большие относительно опорного) и рекурсивной сортировке этих частей.

6. Как нужно изменить приведённые в параграфе алгоритмы, чтобы элементы массива были отсортированы по убыванию?
   Чтобы отсортировать по убыванию, нужно изменить условие сравнения в оба метода: при сравнении элементов их нужно располагать в порядке, где больший элемент стоит перед меньшим.

7. Как вы думаете, можно ли использовать метод «быстрой сортировки» для нечисловых данных, например для символьных строк?
   Да, метод быстрой сортировки можно применять к символьным строкам. Сравнения будут основываться на сортировке по алфавиту или кодировке символов.

8. От чего зависит скорость «быстрой сортировки»? Какой самый лучший и самый худший случай?
   Скорость зависит от выбора опорного элемента. Лучший случай возникает при равномерном распределении элементов (например, уже отсортированные данные), а худший — при массиве, отсортированном в обратном порядке, особенно если опорный элемент всегда выбирается крайним.

9. Как вы думаете, может ли метод «быстрой сортировки» работать дольше, чем метод выбора (или другой «простой» метод)? Если да, то при каких условиях?
   Да, метод быстрой сортировки может работать дольше, чем метод выбора, если данные уже отсортированы в порядке, противоположном вектору опорного элемента (то есть при плохом выборе опорного элемента).
```

1. Программа, которая отсортирует массив и найдет количество уникальных чисел

def unique_count(arr):
    unique_numbers = set(arr)
    sorted_numbers = sorted(arr)
    return sorted_numbers, len(unique_numbers)

Пример использования
arr = [3, 5, 2, 3, 5, 8, 2]
sorted_arr, unique_count_result = unique_count(arr)
print("Отсортированный массив:", sorted_arr)
print("Количество уникальных чисел:", unique_count_result)


2. Сортировка методом камня

def stone_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]  # перестановка
    return arr

Пример использования
arr = [3, 5, 1, 4, 2]
sorted_arr = stone_sort(arr)
print("Отсортированный массив методом камня:", sorted_arr)


3. Вариант пузырьковой сортировки без перестановок

def optimized_bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:  # Если не было перестановок, выходим из цикла
            break
    return arr

Пример использования
arr = [5, 1, 4, 2, 8]
sorted_arr = optimized_bubble_sort(arr)
print("Отсортированный массив (оптимизированный пузырьком):", sorted_arr)


4. Сортировка массива по последней цифре

def sort_by_last_digit(arr):
    sorted_arr = sorted(arr, key=lambda x: x % 10)
    return sorted_arr

Пример использования
arr = [23, 43, 12, 33, 52]
sorted_arr = sort_by_last_digit(arr)
print("Отсортированный массив по последней цифре:", sorted_arr)


5. Сортировка по убыванию суммы цифр чисел

def sum_of_digits(n):
    return sum(int(digit) for digit in str(n))

def sort_by_sum_of_digits(arr):
    sorted_arr = sorted(arr, key=sum_of_digits, reverse=True)
    return sorted_arr

Пример использования
arr = [23, 45, 67, 89, 12]
sorted_arr = sort_by_sum_of_digits(arr)
print("Отсортированный массив по убыванию суммы цифр:", sorted_arr)


6. Сортировка первой половины массива по возрастанию, второй - по убыванию

def sort_half(arr):
    mid = len(arr) // 2
    first_half = sorted(arr[:mid])
    second_half = sorted(arr[mid:], reverse=True)
    return first_half + second_half

Пример использования
arr = [3, 5, 1, 4, 2, 6, 9, 8, 7]
sorted_arr = sort_half(arr)
print("Отсортированный массив (первая половина - возрастание, вторая - убывание):", sorted_arr)


7. Нахождение максимального элемента, встречающегося несколько раз после сортировки

def max_duplicate(arr):
    sorted_arr = sorted(arr)
    duplicates = {}
    
    for num in sorted_arr:
        if num in duplicates:
            duplicates[num] += 1
        else:
            duplicates[num] = 1
            
    max_num = None
    for num, count in duplicates.items():
        if count > 1:
            if max_num is None or num > max_num:
                max_num = num
            
    return max_num

Пример использования
arr = [1, 2, 3, 2, 4, 1, 5, 3]
max_duplicate_num = max_duplicate(arr)
print("Максимальный элемент, встречающийся несколько раз:", max_duplicate_num)
